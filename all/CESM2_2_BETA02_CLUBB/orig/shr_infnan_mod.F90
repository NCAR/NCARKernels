!KGEN-generated Fortran source file 
  
!Generated at : 2019-06-20 14:46:40 
!KGEN version : 0.8.1 
  
!===================================================
! DO NOT EDIT THIS FILE, it was generated using /glade2/scratch2/youngsun/kgensystest/cesm_work/cime/src/externals/genf90/genf90.pl
! Any changes you make to this file may be lost
!===================================================
! Flag representing compiler support of Fortran 2003's
! ieee_arithmetic intrinsic module.


module shr_infnan_mod
!---------------------------------------------------------------------
! Module to test for IEEE Inf and NaN values, which also provides a
! method of setting +/-Inf and signaling or quiet NaN.
! All functions are elemental, and thus work on arrays.
!---------------------------------------------------------------------
! To test for these values, just call the corresponding function, e.g:
!   var_is_nan = shr_infnan_isnan(x)
! You can also use it on arrays:
!   array_contains_nan = any(shr_infnan_isnan(my_array))
!---------------------------------------------------------------------
! To generate these values, assign one of the provided derived-type
! variables to a real:
!   use shr_infnan_mod, only: nan => shr_infnan_nan, &
!                             inf => shr_infnan_inf, &
!                             assignment(=)
!   real(r4) :: my_nan
!   real(r8) :: my_inf_array(2,2)
!   my_nan = nan
!   my_inf_array = inf
! Keep in mind that "shr_infnan_nan" and "shr_infnan_inf" cannot be
! passed to functions that expect real arguments. To pass a real
! NaN, you will have to use shr_infnan_nan to set a local real of
! the correct kind.
!---------------------------------------------------------------------
!
!
!
!
!
!
!

! If we have IEEE_ARITHMETIC, the NaN test is provided for us.


    USE, INTRINSIC :: ieee_arithmetic, ONLY: shr_infnan_isnan => ieee_is_nan 
    USE kgen_utils_mod, ONLY: kgen_dp, kgen_array_sumcheck 
    USE tprof_mod, ONLY: tstart, tstop, tnull, tprnt 


    IMPLICIT NONE 
    PRIVATE 
    SAVE 
! Test functions for NaN/Inf values.

    PUBLIC shr_infnan_isnan 
! Locally defined isnan.


! Derived types for generation of NaN/Inf
! Even though there's no reason to "use" the types directly, some compilers
! might have trouble with an object being used without its type.

! Type representing Not A Number.


! Type representing +/-Infinity.


! Allow assigning reals to NaN or Inf.


! Conversion functions.


! Initialize objects of NaN/Inf type for other modules to use.
! Default NaN is signaling, but also provide snan and qnan to choose
! explicitly.


! Default Inf is positive, but provide posinf to go with neginf.

! Bit patterns for implementation without ieee_arithmetic.
! Note that in order to satisfy gfortran's range check, we have to use
! ibset to set the sign bit from a BOZ pattern.


!---------------------------------------------------------------------
! TEST FUNCTIONS
!---------------------------------------------------------------------
! The "isinf" function simply calls "isposinf" and "isneginf".
!---------------------------------------------------------------------
! TYPE double,real


! TYPE double,real

!---------------------------------------------------------------------
! The "isposinf" and "isneginf" functions get the IEEE class of a
! real, and test to see if the class is equal to ieee_positive_inf
! or ieee_negative_inf.
!---------------------------------------------------------------------
! TYPE double,real


! TYPE double,real

! TYPE double,real


! TYPE double,real

!---------------------------------------------------------------------
! GENERATION FUNCTIONS
!---------------------------------------------------------------------
! Two approaches for generation of NaN and Inf values:
!   1. With Fortran 2003, use the ieee_value intrinsic to get a value
!      from the corresponding class. These are:
!       - ieee_signaling_nan
!       - ieee_quiet_nan
!       - ieee_positive_inf
!       - ieee_negative_inf
!   2. Without Fortran 2003, set the IEEE bit patterns directly.
!      Use BOZ literals to get an integer with the correct bit
!      pattern, then use "transfer" to transfer those bits into a
!      real.
!---------------------------------------------------------------------
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7


! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7


! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

!---------------------------------------------------------------------
! CONVERSION INTERFACES.
!---------------------------------------------------------------------
! Function methods to get reals from nan/inf types.
!---------------------------------------------------------------------


end module shr_infnan_mod