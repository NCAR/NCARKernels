!KGEN-generated Fortran source file 
  
!Generated at : 2019-07-09 12:29:15 
!KGEN version : 0.8.1 
  
!===================================================
! DO NOT EDIT THIS FILE, it was generated using /glade/scratch/youngsun/silhs/silhs_v2/cime/src/externals/genf90/genf90.pl
! Any changes you make to this file may be lost
!===================================================
! Flag representing compiler support of Fortran 2003's
! ieee_arithmetic intrinsic module.


module shr_infnan_mod
!---------------------------------------------------------------------
! Module to test for IEEE Inf and NaN values, which also provides a
! method of setting +/-Inf and signaling or quiet NaN.
! All functions are elemental, and thus work on arrays.
!---------------------------------------------------------------------
! To test for these values, just call the corresponding function, e.g:
!   var_is_nan = shr_infnan_isnan(x)
! You can also use it on arrays:
!   array_contains_nan = any(shr_infnan_isnan(my_array))
!---------------------------------------------------------------------
! To generate these values, assign one of the provided derived-type
! variables to a real:
!   use shr_infnan_mod, only: nan => shr_infnan_nan, &
!                             inf => shr_infnan_inf, &
!                             assignment(=)
!   real(r4) :: my_nan
!   real(r8) :: my_inf_array(2,2)
!   my_nan = nan
!   my_inf_array = inf
! Keep in mind that "shr_infnan_nan" and "shr_infnan_inf" cannot be
! passed to functions that expect real arguments. To pass a real
! NaN, you will have to use shr_infnan_nan to set a local real of
! the correct kind.
!---------------------------------------------------------------------
!
!
!
!
!
!
!

! If we have IEEE_ARITHMETIC, the NaN test is provided for us.


    USE kgen_utils_mod, ONLY: kgen_dp, kgen_array_sumcheck 
    USE tprof_mod, ONLY: tstart, tstop, tnull, tprnt 
    USE kgen_utils_mod, ONLY: check_t, kgen_init_check, kgen_tolerance, kgen_minvalue, kgen_verboselevel, CHECK_IDENTICAL, &
    &CHECK_IN_TOL, CHECK_OUT_TOL 


    IMPLICIT NONE 
    PRIVATE 
    SAVE 
! Test functions for NaN/Inf values.
use shr_kind_mod, only: &
     r4 => SHR_KIND_R4, &
     r8 => SHR_KIND_R8
! Integers of correct size for bit patterns below.
use shr_kind_mod, only: i4 => shr_kind_i4, i8 => shr_kind_i8

! Locally defined isnan.
! Single precision.
integer(i4), parameter :: ssnan_pat = int(Z'7FA00000',i4)
integer(i4), parameter :: sqnan_pat = int(Z'7FC00000',i4)
integer(i4), parameter :: sposinf_pat = int(Z'7F800000',i4)
integer(i4), parameter :: sneginf_pat = ibset(sposinf_pat,bit_size(1_i4)-1)
! Double precision.
integer(i8), parameter :: dsnan_pat = int(Z'7FF4000000000000',i8)
integer(i8), parameter :: dqnan_pat = int(Z'7FF8000000000000',i8)
integer(i8), parameter :: dposinf_pat = int(Z'7FF0000000000000',i8)
integer(i8), parameter :: dneginf_pat = ibset(dposinf_pat,bit_size(1_i8)-1)


! Derived types for generation of NaN/Inf
! Even though there's no reason to "use" the types directly, some compilers
! might have trouble with an object being used without its type.

    PUBLIC shr_infnan_nan_type 
    PUBLIC shr_infnan_inf_type 
    public assignment(=)

! Type representing Not A Number.

type :: shr_infnan_nan_type
   logical :: quiet = .false.
end type shr_infnan_nan_type
! Type representing +/-Infinity.

type :: shr_infnan_inf_type
   logical :: positive = .true.

end type shr_infnan_inf_type
! Allow assigning reals to NaN or Inf.

interface assignment(=)
   module procedure set_nan_0d_double
end interface

! Conversion functions.


! Initialize objects of NaN/Inf type for other modules to use.
! Default NaN is signaling, but also provide snan and qnan to choose
! explicitly.


type(shr_infnan_nan_type), public, parameter :: shr_infnan_nan = &
     shr_infnan_nan_type(.false.)
! Default Inf is positive, but provide posinf to go with neginf.

type(shr_infnan_inf_type), public, parameter :: shr_infnan_posinf = &
     shr_infnan_inf_type(.true.)
type(shr_infnan_inf_type), public, parameter :: shr_infnan_neginf = &
     shr_infnan_inf_type(.false.)
! Bit patterns for implementation without ieee_arithmetic.
! Note that in order to satisfy gfortran's range check, we have to use
! ibset to set the sign bit from a BOZ pattern.
PUBLIC kr_shr_infnan_mod_shr_infnan_nan_type 
PUBLIC kr_shr_infnan_mod_shr_infnan_inf_type 
PUBLIC kv_shr_infnan_mod_shr_infnan_nan_type 
PUBLIC kv_shr_infnan_mod_shr_infnan_inf_type 


!---------------------------------------------------------------------
! TEST FUNCTIONS
!---------------------------------------------------------------------
! The "isinf" function simply calls "isposinf" and "isneginf".
!---------------------------------------------------------------------
! TYPE double,real
  
CONTAINS 
  


! TYPE double,real

!---------------------------------------------------------------------
! The "isposinf" and "isneginf" functions get the IEEE class of a
! real, and test to see if the class is equal to ieee_positive_inf
! or ieee_negative_inf.
!---------------------------------------------------------------------
! TYPE double,real


! TYPE double,real

! TYPE double,real


! TYPE double,real

!---------------------------------------------------------------------
! GENERATION FUNCTIONS
!---------------------------------------------------------------------
! Two approaches for generation of NaN and Inf values:
!   1. With Fortran 2003, use the ieee_value intrinsic to get a value
!      from the corresponding class. These are:
!       - ieee_signaling_nan
!       - ieee_quiet_nan
!       - ieee_positive_inf
!       - ieee_negative_inf
!   2. Without Fortran 2003, set the IEEE bit patterns directly.
!      Use BOZ literals to get an integer with the correct bit
!      pattern, then use "transfer" to transfer those bits into a
!      real.
!---------------------------------------------------------------------
! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7
pure subroutine set_nan_0d_double(output, nan)
  integer(i8), parameter :: snan_pat = dsnan_pat
  integer(i8), parameter :: qnan_pat = dqnan_pat
  real(r8), intent(out) :: output
  type(shr_infnan_nan_type), intent(in) :: nan

  ! Use scalar temporary for performance reasons, to reduce the cost of
  ! the ieee_value call.
  real(r8) :: tmp
  if (nan%quiet) then
     tmp = transfer(qnan_pat, tmp)
  else
     tmp = transfer(snan_pat, tmp)
  end if

  output = tmp

end subroutine set_nan_0d_double


! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7


! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

! TYPE double,real
! DIMS 0,1,2,3,4,5,6,7

!---------------------------------------------------------------------
! CONVERSION INTERFACES.
!---------------------------------------------------------------------
! Function methods to get reals from nan/inf types.
!---------------------------------------------------------------------

!read state subroutine for kr_shr_infnan_mod_shr_infnan_nan_type 
RECURSIVE SUBROUTINE kr_shr_infnan_mod_shr_infnan_nan_type(var, kgen_unit, printname, printvar) 
    TYPE(shr_infnan_nan_type), INTENT(INOUT) :: var 
    INTEGER, INTENT(IN) :: kgen_unit 
    CHARACTER(LEN=*), INTENT(IN) :: printname 
    LOGICAL, INTENT(IN), OPTIONAL :: printvar 
    LOGICAL :: kgen_istrue 
    REAL(KIND=8) :: kgen_array_sum 
      
    READ (UNIT = kgen_unit) var%quiet 
    IF (PRESENT( printvar ) .AND. printvar) THEN 
        WRITE (*, *) "KGEN DEBUG: " // printname // "%quiet = ", var%quiet 
    END IF   
      
END SUBROUTINE kr_shr_infnan_mod_shr_infnan_nan_type 
  
!read state subroutine for kr_shr_infnan_mod_shr_infnan_inf_type 
RECURSIVE SUBROUTINE kr_shr_infnan_mod_shr_infnan_inf_type(var, kgen_unit, printname, printvar) 
    TYPE(shr_infnan_inf_type), INTENT(INOUT) :: var 
    INTEGER, INTENT(IN) :: kgen_unit 
    CHARACTER(LEN=*), INTENT(IN) :: printname 
    LOGICAL, INTENT(IN), OPTIONAL :: printvar 
    LOGICAL :: kgen_istrue 
    REAL(KIND=8) :: kgen_array_sum 
      
    READ (UNIT = kgen_unit) var%positive 
    IF (PRESENT( printvar ) .AND. printvar) THEN 
        WRITE (*, *) "KGEN DEBUG: " // printname // "%positive = ", var%positive 
    END IF   
      
END SUBROUTINE kr_shr_infnan_mod_shr_infnan_inf_type 
  
!verify state subroutine for kv_shr_infnan_mod_shr_infnan_nan_type 
RECURSIVE SUBROUTINE kv_shr_infnan_mod_shr_infnan_nan_type(varname, check_status, var, kgenref_var) 
    CHARACTER(LEN=*), INTENT(IN) :: varname 
    TYPE(check_t), INTENT(INOUT) :: check_status 
    TYPE(shr_infnan_nan_type), INTENT(IN) :: var, kgenref_var 
    TYPE(check_t) :: dtype_check_status, comp_check_status 
    INTEGER :: check_result 
    LOGICAL :: is_print = .FALSE. 
      
    logical :: diff_quiet 
      
    check_status%numTotal = check_status%numTotal + 1 
      
    CALL kgen_init_check(dtype_check_status, rank=check_status%rank) 
    dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
    IF (var%quiet .EQV. kgenref_var%quiet) THEN 
        dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
        IF (kgen_verboseLevel > 2) THEN 
            IF (check_status%rank == 0) THEN 
                WRITE (*, *) trim(adjustl(varname)), "%quiet is IDENTICAL." 
            END IF   
        END IF   
        check_result = CHECK_IDENTICAL 
    ELSE 
        dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
        IF (kgen_verboseLevel > 1) THEN 
            IF (check_status%rank == 0) THEN 
                WRITE (*, *) trim(adjustl(varname)), "%quiet is NOT IDENTICAL." 
            END IF   
        END IF   
        check_result = CHECK_OUT_TOL 
    END IF   
    IF (check_result == CHECK_IDENTICAL) THEN 
        CONTINUE 
    ELSE IF (check_result == CHECK_OUT_TOL) THEN 
        IF (kgen_verboseLevel > 2) THEN 
            IF (check_status%rank ==0) THEN 
                WRITE (*, *) "NOT IMPLEMENTED YET" 
                WRITE (*, *) "" 
            END IF   
        END IF   
    ELSE IF (check_result == CHECK_IN_TOL) THEN 
        IF (kgen_verboseLevel > 2) THEN 
            IF (check_status%rank ==0) THEN 
                WRITE (*, *) "NOT IMPLEMENTED YET" 
                WRITE (*, *) "" 
            END IF   
        END IF   
    END IF   
      
    IF (dtype_check_status%numTotal == dtype_check_status%numIdentical) THEN 
        check_status%numIdentical = check_status%numIdentical + 1 
    ELSE IF (dtype_check_status%numOutTol > 0) THEN 
        check_status%numOutTol = check_status%numOutTol + 1 
    ELSE IF (dtype_check_status%numInTol > 0) THEN 
        check_status%numInTol = check_status%numInTol + 1 
    END IF   
END SUBROUTINE kv_shr_infnan_mod_shr_infnan_nan_type 
  
!verify state subroutine for kv_shr_infnan_mod_shr_infnan_inf_type 
RECURSIVE SUBROUTINE kv_shr_infnan_mod_shr_infnan_inf_type(varname, check_status, var, kgenref_var) 
    CHARACTER(LEN=*), INTENT(IN) :: varname 
    TYPE(check_t), INTENT(INOUT) :: check_status 
    TYPE(shr_infnan_inf_type), INTENT(IN) :: var, kgenref_var 
    TYPE(check_t) :: dtype_check_status, comp_check_status 
    INTEGER :: check_result 
    LOGICAL :: is_print = .FALSE. 
      
    logical :: diff_positive 
      
    check_status%numTotal = check_status%numTotal + 1 
      
    CALL kgen_init_check(dtype_check_status, rank=check_status%rank) 
    dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
    IF (var%positive .EQV. kgenref_var%positive) THEN 
        dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
        IF (kgen_verboseLevel > 2) THEN 
            IF (check_status%rank == 0) THEN 
                WRITE (*, *) trim(adjustl(varname)), "%positive is IDENTICAL." 
            END IF   
        END IF   
        check_result = CHECK_IDENTICAL 
    ELSE 
        dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
        IF (kgen_verboseLevel > 1) THEN 
            IF (check_status%rank == 0) THEN 
                WRITE (*, *) trim(adjustl(varname)), "%positive is NOT IDENTICAL." 
            END IF   
        END IF   
        check_result = CHECK_OUT_TOL 
    END IF   
    IF (check_result == CHECK_IDENTICAL) THEN 
        CONTINUE 
    ELSE IF (check_result == CHECK_OUT_TOL) THEN 
        IF (kgen_verboseLevel > 2) THEN 
            IF (check_status%rank ==0) THEN 
                WRITE (*, *) "NOT IMPLEMENTED YET" 
                WRITE (*, *) "" 
            END IF   
        END IF   
    ELSE IF (check_result == CHECK_IN_TOL) THEN 
        IF (kgen_verboseLevel > 2) THEN 
            IF (check_status%rank ==0) THEN 
                WRITE (*, *) "NOT IMPLEMENTED YET" 
                WRITE (*, *) "" 
            END IF   
        END IF   
    END IF   
      
    IF (dtype_check_status%numTotal == dtype_check_status%numIdentical) THEN 
        check_status%numIdentical = check_status%numIdentical + 1 
    ELSE IF (dtype_check_status%numOutTol > 0) THEN 
        check_status%numOutTol = check_status%numOutTol + 1 
    ELSE IF (dtype_check_status%numInTol > 0) THEN 
        check_status%numInTol = check_status%numInTol + 1 
    END IF   
END SUBROUTINE kv_shr_infnan_mod_shr_infnan_inf_type 
  
end module shr_infnan_mod
